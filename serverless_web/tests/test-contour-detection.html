<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è¼ªå»“æª¢æ¸¬èˆ‡é€è¦–æ ¡æ­£æ¸¬è©¦</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 2rem;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 1rem;
            padding: 2rem;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        h1 {
            color: #333;
            margin-bottom: 1rem;
            text-align: center;
        }

        .status {
            padding: 1rem;
            border-radius: 0.5rem;
            margin-bottom: 2rem;
            text-align: center;
            font-weight: bold;
        }

        .status.loading {
            background: #fff3cd;
            color: #856404;
        }

        .status.ready {
            background: #d4edda;
            color: #155724;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
        }

        .test-controls {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 0.5rem;
            font-size: 1rem;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover {
            background: #218838;
        }

        .btn-warning {
            background: #ffc107;
            color: #333;
        }

        .btn-warning:hover {
            background: #e0a800;
        }

        .test-results {
            margin-bottom: 2rem;
        }

        .test-case {
            border: 2px solid #e0e0e0;
            border-radius: 0.5rem;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .test-case.passed {
            border-color: #28a745;
            background: #f0f9f4;
        }

        .test-case.failed {
            border-color: #dc3545;
            background: #fef5f6;
        }

        .test-case h3 {
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .test-case .icon {
            font-size: 1.5rem;
        }

        .canvas-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-top: 2rem;
        }

        .canvas-item {
            border: 2px solid #e0e0e0;
            border-radius: 0.5rem;
            padding: 1rem;
            background: #f9f9f9;
        }

        .canvas-item h3 {
            margin-bottom: 0.75rem;
            color: #555;
            font-size: 0.95rem;
        }

        canvas {
            width: 100%;
            height: auto;
            border: 1px solid #ddd;
            border-radius: 0.25rem;
            background: white;
        }

        .log-console {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 1rem;
            border-radius: 0.5rem;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            max-height: 300px;
            overflow-y: auto;
            margin-top: 2rem;
        }

        .log-entry {
            margin-bottom: 0.25rem;
        }

        .log-entry.success {
            color: #4ec9b0;
        }

        .log-entry.error {
            color: #f48771;
        }

        .log-entry.info {
            color: #4fc1ff;
        }

        input[type="file"] {
            margin-bottom: 1rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ” è¼ªå»“æª¢æ¸¬èˆ‡é€è¦–æ ¡æ­£æ¸¬è©¦</h1>

        <div id="status" class="status loading">
            â³ æ­£åœ¨è¼‰å…¥ OpenCV.js...
        </div>

        <div class="test-controls">
            <input type="file" id="file-input" accept="image/*" style="display: none;">
            <button id="upload-btn" class="btn btn-primary" disabled>ğŸ“ ä¸Šå‚³æ¸¬è©¦å½±åƒ</button>
            <button id="run-all-btn" class="btn btn-success" disabled>â–¶ï¸ åŸ·è¡Œæ‰€æœ‰æ¸¬è©¦</button>
            <button id="clear-btn" class="btn btn-warning">ğŸ—‘ï¸ æ¸…é™¤çµæœ</button>
        </div>

        <div id="test-results" class="test-results"></div>

        <div class="canvas-grid" id="canvas-grid"></div>

        <div class="log-console" id="log-console"></div>
    </div>

    <!-- OpenCV.js åˆå§‹åŒ– -->
    <script>
        var Module = {
            onRuntimeInitialized() {
                window.testRunner.onOpenCVReady();
            }
        };
    </script>

    <!-- è¼‰å…¥ OpenCV.js -->
    <script async src="../assets/lib/opencv.js"></script>

    <!-- æ¸¬è©¦è…³æœ¬ -->
    <script>
        class ContourDetectionTestRunner {
            constructor() {
                this.testResults = [];
                this.processor = null;
                this.currentImage = null;

                this.elements = {
                    status: document.getElementById('status'),
                    uploadBtn: document.getElementById('upload-btn'),
                    runAllBtn: document.getElementById('run-all-btn'),
                    clearBtn: document.getElementById('clear-btn'),
                    fileInput: document.getElementById('file-input'),
                    testResults: document.getElementById('test-results'),
                    canvasGrid: document.getElementById('canvas-grid'),
                    logConsole: document.getElementById('log-console')
                };

                this.setupEventListeners();
            }

            setupEventListeners() {
                this.elements.uploadBtn.addEventListener('click', () => {
                    this.elements.fileInput.click();
                });

                this.elements.fileInput.addEventListener('change', (e) => {
                    this.handleFileUpload(e);
                });

                this.elements.runAllBtn.addEventListener('click', () => {
                    this.runAllTests();
                });

                this.elements.clearBtn.addEventListener('click', () => {
                    this.clearResults();
                });
            }

            onOpenCVReady() {
                this.log('OpenCV.js è¼‰å…¥å®Œæˆï¼', 'success');
                this.updateStatus('ready', 'âœ… OpenCV.js å·²å°±ç·’');

                // å•Ÿç”¨æŒ‰éˆ•
                this.elements.uploadBtn.disabled = false;
                this.elements.runAllBtn.disabled = false;

                // å‹•æ…‹è¼‰å…¥ ImageProcessor
                this.loadImageProcessor();
            }

            async loadImageProcessor() {
                try {
                    // è¼‰å…¥ ImageProcessor é¡åˆ¥
                    const script = document.createElement('script');
                    script.src = '../assets/js/image-processor.js';
                    script.onload = () => {
                        this.processor = new ImageProcessor();
                        this.log('ImageProcessor å·²åˆå§‹åŒ–', 'success');
                    };
                    script.onerror = () => {
                        this.log('ImageProcessor è¼‰å…¥å¤±æ•—', 'error');
                    };
                    document.head.appendChild(script);
                } catch (error) {
                    this.log('è¼‰å…¥ ImageProcessor æ™‚ç™¼ç”ŸéŒ¯èª¤: ' + error.message, 'error');
                }
            }

            async handleFileUpload(e) {
                const file = e.target.files[0];
                if (!file) return;

                try {
                    this.log(`è¼‰å…¥æª”æ¡ˆ: ${file.name}`, 'info');

                    const img = await this.loadImage(file);
                    this.currentImage = img;

                    this.log(`å½±åƒè¼‰å…¥æˆåŠŸ (${img.width}x${img.height})`, 'success');

                    // è‡ªå‹•åŸ·è¡Œæ¸¬è©¦
                    this.runAllTests();

                } catch (error) {
                    this.log('è¼‰å…¥å½±åƒå¤±æ•—: ' + error.message, 'error');
                }
            }

            loadImage(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const img = new Image();
                        img.onload = () => resolve(img);
                        img.onerror = () => reject(new Error('å½±åƒè¼‰å…¥å¤±æ•—'));
                        img.src = e.target.result;
                    };
                    reader.onerror = () => reject(new Error('æª”æ¡ˆè®€å–å¤±æ•—'));
                    reader.readAsDataURL(file);
                });
            }

            async runAllTests() {
                if (!this.currentImage) {
                    this.log('è«‹å…ˆä¸Šå‚³æ¸¬è©¦å½±åƒ', 'error');
                    return;
                }

                this.clearResults();
                this.log('é–‹å§‹åŸ·è¡Œæ¸¬è©¦å¥—ä»¶...', 'info');

                const tests = [
                    { name: 'Canny é‚Šç·£æª¢æ¸¬', fn: () => this.testCannyEdgeDetection() },
                    { name: 'è¼ªå»“æŸ¥æ‰¾', fn: () => this.testFindContours() },
                    { name: 'å››é‚Šå½¢è¼ªå»“ç¯©é¸', fn: () => this.testQuadrilateralFiltering() },
                    { name: 'è§’é»æ’åº', fn: () => this.testCornerOrdering() },
                    { name: 'é€è¦–è®Šæ›çŸ©é™£è¨ˆç®—', fn: () => this.testPerspectiveTransformMatrix() },
                    { name: 'å®Œæ•´é€è¦–æ ¡æ­£æµç¨‹', fn: () => this.testCompletePerspectiveCorrection() }
                ];

                for (const test of tests) {
                    try {
                        this.log(`åŸ·è¡Œæ¸¬è©¦: ${test.name}`, 'info');
                        await test.fn();
                        this.addTestResult(test.name, true, 'æ¸¬è©¦é€šé');
                    } catch (error) {
                        this.log(`æ¸¬è©¦å¤±æ•—: ${test.name} - ${error.message}`, 'error');
                        this.addTestResult(test.name, false, error.message);
                    }
                }

                this.log('æ¸¬è©¦å¥—ä»¶åŸ·è¡Œå®Œç•¢', 'success');
            }

            // ==================== æ¸¬è©¦æ¡ˆä¾‹ ====================

            testCannyEdgeDetection() {
                if (!this.processor || !this.processor.cannyEdgeDetection) {
                    throw new Error('cannyEdgeDetection æ–¹æ³•å°šæœªå¯¦ç¾');
                }

                const mat = cv.imread(this.currentImage);
                let gray = new cv.Mat();
                cv.cvtColor(mat, gray, cv.COLOR_RGBA2GRAY);

                const edges = this.processor.cannyEdgeDetection(gray, 50, 150);

                // é©—è­‰çµæœ
                if (!edges || edges.rows === 0 || edges.cols === 0) {
                    throw new Error('Canny é‚Šç·£æª¢æ¸¬è¿”å›ç©ºçµæœ');
                }

                this.displayCanvas('Canny é‚Šç·£æª¢æ¸¬', edges);

                // æ¸…ç†
                mat.delete();
                gray.delete();
                edges.delete();

                this.log('Canny é‚Šç·£æª¢æ¸¬æ¸¬è©¦é€šé', 'success');
            }

            testFindContours() {
                if (!this.processor || !this.processor.findContours) {
                    throw new Error('findContours æ–¹æ³•å°šæœªå¯¦ç¾');
                }

                const mat = cv.imread(this.currentImage);
                let gray = new cv.Mat();
                let binary = new cv.Mat();

                cv.cvtColor(mat, gray, cv.COLOR_RGBA2GRAY);
                cv.adaptiveThreshold(gray, binary, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 11, 2);

                const contours = this.processor.findContours(binary);

                // é©—è­‰çµæœ
                if (!contours || contours.size() === 0) {
                    throw new Error('æœªæ‰¾åˆ°ä»»ä½•è¼ªå»“');
                }

                this.log(`æ‰¾åˆ° ${contours.size()} å€‹è¼ªå»“`, 'success');

                // è¦–è¦ºåŒ–è¼ªå»“ï¼ˆç›´æ¥ç¹ªè£½æ‰€æœ‰è¼ªå»“ï¼Œä¸éœ€è¦éæ­·ï¼‰
                let visual = mat.clone();
                cv.drawContours(visual, contours, -1, new cv.Scalar(0, 255, 0, 255), 2);
                this.displayCanvas('æ‰¾åˆ°çš„è¼ªå»“', visual);

                // æ¸…ç†
                mat.delete();
                gray.delete();
                binary.delete();
                visual.delete();
                contours.delete();  // MatVector ç›´æ¥åˆªé™¤

                this.log('è¼ªå»“æŸ¥æ‰¾æ¸¬è©¦é€šé', 'success');
            }

            testQuadrilateralFiltering() {
                if (!this.processor || !this.processor.filterQuadrilateralContours) {
                    throw new Error('filterQuadrilateralContours æ–¹æ³•å°šæœªå¯¦ç¾');
                }

                const mat = cv.imread(this.currentImage);
                let gray = new cv.Mat();
                let binary = new cv.Mat();

                cv.cvtColor(mat, gray, cv.COLOR_RGBA2GRAY);
                cv.adaptiveThreshold(gray, binary, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 11, 2);

                const allContours = this.processor.findContours(binary);
                const quadContours = this.processor.filterQuadrilateralContours(allContours, mat.rows * mat.cols);

                // é©—è­‰çµæœ
                if (!quadContours || quadContours.length === 0) {
                    throw new Error('æœªæ‰¾åˆ°å››é‚Šå½¢è¼ªå»“');
                }

                this.log(`ç¯©é¸å‡º ${quadContours.length} å€‹å››é‚Šå½¢è¼ªå»“`, 'success');

                // è¦–è¦ºåŒ–å››é‚Šå½¢è¼ªå»“ï¼ˆå»ºç«‹ MatVector ç”¨æ–¼ç¹ªè£½ï¼‰
                let visual = mat.clone();
                const quadVector = new cv.MatVector();
                quadContours.forEach(c => quadVector.push_back(c));

                for (let i = 0; i < quadVector.size(); i++) {
                    cv.drawContours(visual, quadVector, i, new cv.Scalar(255, 0, 0, 255), 3);
                }
                this.displayCanvas('å››é‚Šå½¢è¼ªå»“', visual);

                // æ¸…ç†
                mat.delete();
                gray.delete();
                binary.delete();
                visual.delete();
                allContours.delete();  // MatVector ç›´æ¥åˆªé™¤
                quadContours.forEach(c => c.delete());  // Mat é™£åˆ—é€ä¸€åˆªé™¤
                quadVector.delete();  // æ–°å»ºçš„ MatVector ä¹Ÿè¦åˆªé™¤

                this.log('å››é‚Šå½¢è¼ªå»“ç¯©é¸æ¸¬è©¦é€šé', 'success');
            }

            testCornerOrdering() {
                if (!this.processor || !this.processor.orderCorners) {
                    throw new Error('orderCorners æ–¹æ³•å°šæœªå¯¦ç¾');
                }

                // å»ºç«‹æ¸¬è©¦é»ï¼ˆä¸æŒ‰é †åºï¼‰
                const testPoints = [
                    { x: 300, y: 400 },  // å³ä¸‹
                    { x: 100, y: 100 },  // å·¦ä¸Š
                    { x: 400, y: 100 },  // å³ä¸Š
                    { x: 50, y: 350 }    // å·¦ä¸‹
                ];

                const ordered = this.processor.orderCorners(testPoints);

                // é©—è­‰é †åºï¼šå·¦ä¸Šã€å³ä¸Šã€å³ä¸‹ã€å·¦ä¸‹
                if (ordered.length !== 4) {
                    throw new Error('è¿”å›çš„è§’é»æ•¸é‡ä¸æ­£ç¢º');
                }

                // å·¦ä¸Šè§’æ‡‰è©²æ˜¯ x å’Œ y æœ€å°çš„é»
                if (ordered[0].x !== 100 || ordered[0].y !== 100) {
                    throw new Error('å·¦ä¸Šè§’æ’åºéŒ¯èª¤');
                }

                this.log('è§’é»æ’åºï¼šå·¦ä¸Š â†’ å³ä¸Š â†’ å³ä¸‹ â†’ å·¦ä¸‹', 'success');
                this.log(`çµæœ: [${ordered.map(p => `(${p.x},${p.y})`).join(', ')}]`, 'info');

                this.log('è§’é»æ’åºæ¸¬è©¦é€šé', 'success');
            }

            testPerspectiveTransformMatrix() {
                if (!this.processor || !this.processor.getPerspectiveTransform) {
                    throw new Error('getPerspectiveTransform æ–¹æ³•å°šæœªå¯¦ç¾');
                }

                // ä¾†æºé»ï¼ˆå‚¾æ–œçš„å››é‚Šå½¢ï¼‰
                const srcPoints = [
                    { x: 100, y: 100 },
                    { x: 400, y: 80 },
                    { x: 420, y: 400 },
                    { x: 80, y: 420 }
                ];

                // ç›®æ¨™é»ï¼ˆæ­£æ–¹å½¢ï¼‰
                const dstPoints = [
                    { x: 0, y: 0 },
                    { x: 500, y: 0 },
                    { x: 500, y: 500 },
                    { x: 0, y: 500 }
                ];

                const matrix = this.processor.getPerspectiveTransform(srcPoints, dstPoints);

                // é©—è­‰çŸ©é™£
                if (!matrix || matrix.rows !== 3 || matrix.cols !== 3) {
                    throw new Error('é€è¦–è®Šæ›çŸ©é™£æ ¼å¼éŒ¯èª¤');
                }

                this.log('é€è¦–è®Šæ›çŸ©é™£è¨ˆç®—æˆåŠŸ', 'success');
                matrix.delete();

                this.log('é€è¦–è®Šæ›çŸ©é™£æ¸¬è©¦é€šé', 'success');
            }

            testCompletePerspectiveCorrection() {
                if (!this.processor || !this.processor.correctPerspective) {
                    throw new Error('correctPerspective æ–¹æ³•å°šæœªå¯¦ç¾');
                }

                const mat = cv.imread(this.currentImage);

                const result = this.processor.correctPerspective(mat);

                // é©—è­‰çµæœ
                if (!result || !result.corrected) {
                    throw new Error('é€è¦–æ ¡æ­£å¤±æ•—');
                }

                if (!result.corners || result.corners.length !== 4) {
                    throw new Error('è§’é»æª¢æ¸¬å¤±æ•—');
                }

                this.log(`æª¢æ¸¬åˆ°çš„è§’é»: ${JSON.stringify(result.corners)}`, 'info');

                // é¡¯ç¤ºçµæœ
                this.displayCanvas('åŸå§‹å½±åƒ', mat);
                this.displayCanvas('æ ¡æ­£å¾Œå½±åƒ', result.corrected);

                if (result.visualization) {
                    this.displayCanvas('è§’é»è¦–è¦ºåŒ–', result.visualization);
                    result.visualization.delete();
                }

                // æ¸…ç†
                mat.delete();
                result.corrected.delete();

                this.log('å®Œæ•´é€è¦–æ ¡æ­£æ¸¬è©¦é€šé', 'success');
            }

            // ==================== è¼”åŠ©æ–¹æ³• ====================

            displayCanvas(title, mat) {
                const canvasItem = document.createElement('div');
                canvasItem.className = 'canvas-item';

                const h3 = document.createElement('h3');
                h3.textContent = title;

                const canvas = document.createElement('canvas');
                canvas.id = `canvas-${Date.now()}-${Math.random()}`;

                canvasItem.appendChild(h3);
                canvasItem.appendChild(canvas);
                this.elements.canvasGrid.appendChild(canvasItem);

                cv.imshow(canvas, mat);
            }

            addTestResult(name, passed, message) {
                const testCase = document.createElement('div');
                testCase.className = `test-case ${passed ? 'passed' : 'failed'}`;

                const icon = passed ? 'âœ…' : 'âŒ';
                const status = passed ? 'é€šé' : 'å¤±æ•—';

                testCase.innerHTML = `
                    <h3><span class="icon">${icon}</span> ${name} - ${status}</h3>
                    <p>${message}</p>
                `;

                this.elements.testResults.appendChild(testCase);
                this.testResults.push({ name, passed, message });
            }

            log(message, type = 'info') {
                const entry = document.createElement('div');
                entry.className = `log-entry ${type}`;
                entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                this.elements.logConsole.appendChild(entry);
                this.elements.logConsole.scrollTop = this.elements.logConsole.scrollHeight;

                console.log(message);
            }

            updateStatus(status, message) {
                this.elements.status.className = `status ${status}`;
                this.elements.status.textContent = message;
            }

            clearResults() {
                this.elements.testResults.innerHTML = '';
                this.elements.canvasGrid.innerHTML = '';
                this.testResults = [];
                this.log('æ¸…é™¤æ‰€æœ‰æ¸¬è©¦çµæœ', 'info');
            }
        }

        // åˆå§‹åŒ–æ¸¬è©¦åŸ·è¡Œå™¨
        window.testRunner = new ContourDetectionTestRunner();
    </script>
</body>
</html>
