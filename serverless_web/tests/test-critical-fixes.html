<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Critical Fixes 驗證測試 - OMR Checker</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            background: #f5f5f5;
        }

        .test-section {
            background: white;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        h1 {
            color: #333;
            border-bottom: 2px solid #f44336;
            padding-bottom: 0.5rem;
        }

        h2 {
            color: #666;
            margin-top: 0;
        }

        .status {
            padding: 0.5rem 1rem;
            border-radius: 4px;
            margin: 0.5rem 0;
            font-weight: bold;
        }

        .status.pending {
            background: #FFF3CD;
            color: #856404;
        }

        .status.running {
            background: #D1ECF1;
            color: #0C5460;
        }

        .status.success {
            background: #D4EDDA;
            color: #155724;
        }

        .status.error {
            background: #F8D7DA;
            color: #721C24;
        }

        button {
            padding: 0.75rem 1.5rem;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            margin: 0.5rem 0.5rem 0.5rem 0;
        }

        button:hover {
            background: #d32f2f;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .log {
            background: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 1rem;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }

        .log-entry {
            margin: 0.25rem 0;
            padding: 0.25rem;
        }

        .log-entry.info { color: #0C5460; }
        .log-entry.success { color: #155724; }
        .log-entry.error { color: #721C24; }
        .log-entry.warn { color: #856404; }

        code {
            background: #f4f4f4;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }
    </style>
</head>
<body>
    <h1>🔴 Critical Fixes 驗證測試</h1>
    <p>此測試用於驗證 Stage 6 的 3 個關鍵問題修復：</p>
    <ol>
        <li><strong>Blob URL Memory Leak</strong>: 驗證 Blob URLs 正確釋放</li>
        <li><strong>Data Validation</strong>: 驗證 answers 和 metadata 類型檢查</li>
        <li><strong>Global Variable Pollution</strong>: 驗證無全域變數污染</li>
    </ol>

    <!-- 測試 1: Data Validation -->
    <div class="test-section">
        <h2>測試 1: Data Validation - 驗證資料型別檢查</h2>
        <p>測試 <code>answers</code> 和 <code>metadata</code> 必須是物件類型</p>
        <div id="test1-status" class="status pending">等待測試</div>
        <button onclick="runTest1()">執行測試</button>
        <div id="test1-log" class="log"></div>
    </div>

    <!-- 測試 2: Blob URL Tracking -->
    <div class="test-section">
        <h2>測試 2: Blob URL Tracking - 驗證 activeBlobUrls 存在</h2>
        <p>測試 OMRApp 類別中是否有 <code>activeBlobUrls</code> 和 <code>revokeAllBlobUrls()</code></p>
        <div id="test2-status" class="status pending">等待測試</div>
        <button onclick="runTest2()">執行測試</button>
        <div id="test2-log" class="log"></div>
    </div>

    <!-- 測試 3: Global Variable Check -->
    <div class="test-section">
        <h2>測試 3: Global Variable Check - 驗證無全域污染</h2>
        <p>檢查全域命名空間是否有 <code>app</code> 變數</p>
        <div id="test3-status" class="status pending">等待測試</div>
        <button onclick="runTest3()">執行測試</button>
        <div id="test3-log" class="log"></div>
    </div>

    <!-- 執行所有測試 -->
    <div class="test-section">
        <h2>🚀 執行所有測試</h2>
        <button onclick="runAllTests()" style="background: #2196F3;">執行全部測試</button>
    </div>

    <script src="../assets/js/storage.js"></script>
    <script>
        // 測試工具函數
        function log(testId, message, type = 'info') {
            const logDiv = document.getElementById(`${testId}-log`);
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function setStatus(testId, status, message) {
            const statusDiv = document.getElementById(`${testId}-status`);
            statusDiv.className = `status ${status}`;
            statusDiv.textContent = message;
        }

        // 建立測試用影像 Blob
        function createTestImageBlob() {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                canvas.width = 100;
                canvas.height = 100;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#4CAF50';
                ctx.fillRect(0, 0, 100, 100);
                canvas.toBlob(resolve, 'image/png');
            });
        }

        // 測試 1: Data Validation
        async function runTest1() {
            const testId = 'test1';
            setStatus(testId, 'running', '測試進行中...');
            log(testId, '開始測試資料型別驗證', 'info');

            try {
                const storage = new OMRStorage();
                await storage.init();

                const imageBlob = await createTestImageBlob();
                let testsPassed = 0;
                let totalTests = 4;

                // 測試 1.1: answers 為 string (應該失敗)
                log(testId, '測試 1.1: answers 為 string', 'info');
                try {
                    await storage.saveResult({
                        originalImageBlob: imageBlob,
                        processedImageBlob: imageBlob,
                        answers: "invalid string",  // ❌ 應該拋出錯誤
                        score: 80,
                        templateName: 'test',
                        metadata: {}
                    });
                    log(testId, '✗ 測試 1.1 失敗: 應該拋出錯誤但沒有', 'error');
                } catch (error) {
                    if (error.message.includes('answers 必須是物件類型')) {
                        log(testId, '✓ 測試 1.1 通過: 正確捕捉到錯誤', 'success');
                        testsPassed++;
                    } else {
                        log(testId, `✗ 測試 1.1 失敗: 錯誤訊息不正確 - ${error.message}`, 'error');
                    }
                }

                // 測試 1.2: answers 為 array (應該失敗)
                log(testId, '測試 1.2: answers 為 array', 'info');
                try {
                    await storage.saveResult({
                        originalImageBlob: imageBlob,
                        processedImageBlob: imageBlob,
                        answers: ["A", "B", "C"],  // ❌ 應該拋出錯誤
                        score: 80,
                        templateName: 'test',
                        metadata: {}
                    });
                    log(testId, '✗ 測試 1.2 失敗: 應該拋出錯誤但沒有', 'error');
                } catch (error) {
                    if (error.message.includes('answers 必須是物件類型')) {
                        log(testId, '✓ 測試 1.2 通過: 正確捕捉到錯誤', 'success');
                        testsPassed++;
                    } else {
                        log(testId, `✗ 測試 1.2 失敗: 錯誤訊息不正確 - ${error.message}`, 'error');
                    }
                }

                // 測試 1.3: metadata 為 string (應該失敗)
                log(testId, '測試 1.3: metadata 為 string', 'info');
                try {
                    await storage.saveResult({
                        originalImageBlob: imageBlob,
                        processedImageBlob: imageBlob,
                        answers: {},
                        score: 80,
                        templateName: 'test',
                        metadata: "invalid string"  // ❌ 應該拋出錯誤
                    });
                    log(testId, '✗ 測試 1.3 失敗: 應該拋出錯誤但沒有', 'error');
                } catch (error) {
                    if (error.message.includes('metadata 必須是物件類型')) {
                        log(testId, '✓ 測試 1.3 通過: 正確捕捉到錯誤', 'success');
                        testsPassed++;
                    } else {
                        log(testId, `✗ 測試 1.3 失敗: 錯誤訊息不正確 - ${error.message}`, 'error');
                    }
                }

                // 測試 1.4: 正確的物件類型 (應該成功)
                log(testId, '測試 1.4: 正確的物件類型', 'info');
                try {
                    const id = await storage.saveResult({
                        originalImageBlob: imageBlob,
                        processedImageBlob: imageBlob,
                        answers: { 1: 'A', 2: 'B' },  // ✓ 正確
                        score: 80,
                        templateName: 'test',
                        metadata: { testName: 'Test 1.4' }  // ✓ 正確
                    });
                    log(testId, `✓ 測試 1.4 通過: 成功儲存，ID: ${id}`, 'success');
                    testsPassed++;

                    // 清理
                    await storage.deleteResult(id);
                } catch (error) {
                    log(testId, `✗ 測試 1.4 失敗: ${error.message}`, 'error');
                }

                // 總結
                if (testsPassed === totalTests) {
                    log(testId, `✅ 所有子測試通過 (${testsPassed}/${totalTests})`, 'success');
                    setStatus(testId, 'success', '✓ 測試通過');
                } else {
                    log(testId, `⚠ 部分測試失敗 (${testsPassed}/${totalTests})`, 'warn');
                    setStatus(testId, 'error', `✗ 部分測試失敗 (${testsPassed}/${totalTests})`);
                }

            } catch (error) {
                log(testId, `✗ 錯誤: ${error.message}`, 'error');
                setStatus(testId, 'error', '✗ 測試失敗');
            }
        }

        // 測試 2: Blob URL Tracking
        async function runTest2() {
            const testId = 'test2';
            setStatus(testId, 'running', '測試進行中...');
            log(testId, '開始測試 Blob URL 追蹤機制', 'info');

            try {
                // 檢查 app.js 是否已載入 (透過檢查全域是否有相關函數或類別)
                log(testId, '注意: 此測試需要在主應用程式中執行才能完整驗證', 'warn');
                log(testId, '目前僅檢查程式碼結構', 'info');

                // 透過 fetch 讀取 app.js 程式碼並檢查
                const response = await fetch('../assets/js/app.js');
                const appJsCode = await response.text();

                let testsPassed = 0;
                let totalTests = 3;

                // 檢查 1: activeBlobUrls 存在
                if (appJsCode.includes('this.activeBlobUrls = new Set()')) {
                    log(testId, '✓ 找到 activeBlobUrls 初始化', 'success');
                    testsPassed++;
                } else {
                    log(testId, '✗ 未找到 activeBlobUrls 初始化', 'error');
                }

                // 檢查 2: revokeAllBlobUrls 方法存在
                if (appJsCode.includes('revokeAllBlobUrls()')) {
                    log(testId, '✓ 找到 revokeAllBlobUrls() 方法', 'success');
                    testsPassed++;
                } else {
                    log(testId, '✗ 未找到 revokeAllBlobUrls() 方法', 'error');
                }

                // 檢查 3: renderHistoryList 中呼叫 revokeAllBlobUrls
                if (appJsCode.includes('this.revokeAllBlobUrls()') &&
                    appJsCode.includes('renderHistoryList(results)')) {
                    log(testId, '✓ renderHistoryList 中呼叫 revokeAllBlobUrls', 'success');
                    testsPassed++;
                } else {
                    log(testId, '✗ renderHistoryList 中未呼叫 revokeAllBlobUrls', 'error');
                }

                // 總結
                if (testsPassed === totalTests) {
                    log(testId, `✅ 所有檢查通過 (${testsPassed}/${totalTests})`, 'success');
                    setStatus(testId, 'success', '✓ 測試通過');
                } else {
                    log(testId, `⚠ 部分檢查失敗 (${testsPassed}/${totalTests})`, 'warn');
                    setStatus(testId, 'error', `✗ 部分檢查失敗 (${testsPassed}/${totalTests})`);
                }

            } catch (error) {
                log(testId, `✗ 錯誤: ${error.message}`, 'error');
                setStatus(testId, 'error', '✗ 測試失敗');
            }
        }

        // 測試 3: Global Variable Check
        async function runTest3() {
            const testId = 'test3';
            setStatus(testId, 'running', '測試進行中...');
            log(testId, '開始檢查全域變數污染', 'info');

            try {
                // 透過 fetch 讀取 app.js 程式碼並檢查
                const response = await fetch('../assets/js/app.js');
                const appJsCode = await response.text();

                let testsPassed = 0;
                let totalTests = 3;

                // 檢查 1: 不應有 "let app;" 或 "var app;" 在全域範圍
                if (!appJsCode.includes('let app;') && !appJsCode.includes('var app;')) {
                    log(testId, '✓ 未找到全域 app 變數宣告', 'success');
                    testsPassed++;
                } else {
                    log(testId, '✗ 找到全域 app 變數宣告', 'error');
                }

                // 檢查 2: 不應有 onclick="app.xxx" 的 inline handler
                if (!appJsCode.includes('onclick="app.')) {
                    log(testId, '✓ 未找到 inline onclick handler', 'success');
                    testsPassed++;
                } else {
                    log(testId, '✗ 找到 inline onclick handler', 'error');
                }

                // 檢查 3: 應使用事件委派 (addEventListener with event delegation)
                if (appJsCode.includes('this.elements.historyList.addEventListener(\'click\'')) {
                    log(testId, '✓ 找到事件委派實作', 'success');
                    testsPassed++;
                } else {
                    log(testId, '✗ 未找到事件委派實作', 'error');
                }

                // 總結
                if (testsPassed === totalTests) {
                    log(testId, `✅ 所有檢查通過 (${testsPassed}/${totalTests})`, 'success');
                    setStatus(testId, 'success', '✓ 測試通過');
                } else {
                    log(testId, `⚠ 部分檢查失敗 (${testsPassed}/${totalTests})`, 'warn');
                    setStatus(testId, 'error', `✗ 部分檢查失敗 (${testsPassed}/${totalTests})`);
                }

            } catch (error) {
                log(testId, `✗ 錯誤: ${error.message}`, 'error');
                setStatus(testId, 'error', '✗ 測試失敗');
            }
        }

        // 執行所有測試
        async function runAllTests() {
            console.log('🚀 開始執行所有 Critical Fixes 測試');

            await runTest1();
            await new Promise(resolve => setTimeout(resolve, 500));

            await runTest2();
            await new Promise(resolve => setTimeout(resolve, 500));

            await runTest3();

            console.log('✅ 所有測試執行完成');
            alert('所有測試執行完成！請檢查結果。');
        }
    </script>
</body>
</html>
